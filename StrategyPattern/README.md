## 일반적인 상속 구조 형태 단점

- 서브클래스에서 코드가 중복된다.
- 모든 오리의 행동을 알기 힘들다.
- 실행시에 특징을 바꾸기 힘들다.
- 코드를 변경했을 때 다른 오리들에게 원치 않은 영향을 끼칠 수 있다.

오리라는 클래스를 상속받는 청둥오리, 빨간머리오리, 고무오리, 가짜오리가 존재  
오리는 소리내고, 수영하고, 날고 화면에 보여질 수 있음  
이때 고무오리의 소리는 상속받은것과 다른 소리가 나야 하고 날지 못함  
가짜오리는 소리도 못내고 날지도 못함 이를 오버라이딩하여 명시적으로 작성해줘야함

특이한 케이스 그리고 다양한 케이스의 오리가 추가될때마다 상속받는 메소드를 상황에 따라 오버라이딩 해줘야하고 이렇게 무수히 많아진 오리들의 행동을 파악하기란 쉽지 않음

## 인터페이스로 해결하기

자바스크립트에서는 인터페이스라는게 없기때문에 덕타이핑을 통해 이를 구현해야한다.  
우선 인터페이스가 무엇인지 이해할 필요가 있다.  
인터페이스는 메서드 목록을 선언한다. 이러한 메서드는 내용이 없다.

그러나 인터페이스도 해결책은 아니다. 코드를 재사용하지 않고 날거나 우는 오리더라도 그 방식이 다를 수 있다.

## 객체 지향의 기초

- 추상화
- 캡슐화
- 다형성
- 상속

## 객체지향 원칙

- 바뀌는 부분은 캡슐화 한다
- 상속보다는 구성을 활용한다
- 구현보다는 인터페이스에 맞춰서 프로그래밍 한다

## 전략패턴

전략패턴은 알고리즘군을 정의하고 캡슐화하여 각각의 알고리즘군을 수정해서 쓸 수 있게 해준다.  
전략패턴을 사용하면 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경 가능

## 자바스크립트로 전략패턴 구현하기

책의 예제에는 자바코드로 구현되어있다.  
상속개념은 자바스크립트로도 비슷하게 구현 가능하지만 인터페이스는 별도로 존재하지 않기 때문에 책의 예제와 동일한 방식으로 구현하는데에는 어려움이 있다.

전략 패턴의 핵심은 바뀌는 부분을 재사용이 가능하도록 캡슐화를 하는것이다.  
상속으로 구현하게되면 사용하지 않더라도 매번 해당 메소드에 대해 오버라이딩을 해야만한다.

### 오리 클래스 구현

```js
class 오리 {
  울다() {
    console.log('꽥꽥')
  }

  날다() {
    console.log('오리날다')
  }

  보여지는것() {
    console.log('오리')
  }

  수영() {
    console.log('수영')
  }
}
```

### 오리를 상속받는 다양한 서브클래스 구현

```js
class 청동오리 extends 오리 {
  보여지는것() {
    console.log('청동오리')
  }
}
class 고무오리 extends 오리 {
  보여지는것() {
    console.log('고무오리')
  }
}
class 나무오리 extends 오리 {
  보여지는것() {
    console.log('나무오리')
  }
}
```

### 메소드 실행

```js
const 청동 = new 청동오리()
const 고무 = new 고무오리()
const 나무 = new 나무오리()

청동.울다() // 꽥꽥
고무.울다() // 꽥꽥
나무.울다() // 꽥꽥

청동.날다() // 오리날다
고무.날다() // 오리날다
나무.날다() // 오리날다

청동.보여지는것() // 청동오리
고무.보여지는것() // 고무오리
나무.보여지는것() // 나무오리
```

이쯤되면 무언가 이상하다는걸 확인할 수 있다. 고무오리가 어떻게 꽥꽥 울수 있는지? 고무오리는 삑삑 소리가 나야할것같은데 그리고 나무오리는 울음소리 낼 수가 없다.

또한 고무오리와 나무오리는 날 수 없다. 무언가 잘못되었고 바꿀 필요성이 있다. 현재 상태에서 상속을 유지하면서 원하는 결과를 위해서는 오버라이딩을 할 수 있다.

```js
class 고무오리 extends 오리 {
  울다() {
    console.log('삑삑')
  }

  날다() {
    return
  }
}
```

해결이 된것같다. 그러나 만약 수퍼 클래스에 새로운 메소드가 추가가되고 그 메소드는 고무오리와 상관없는 메소드라면 아무 동작을 수행하기 않기위한 오버로드 코드가 고무오리같은 해당사항이 없는 무수한 많은 가짜 오리에 오버라이딩 코드를 일일이 찾아서 작성해 줘야 한다.

유지보수면에서 매우 나쁘다. 그리고 놓칠 가능성도 매우 높다. 가짜오리중에서도 고무오리처럼 소리가 날수도 나무오리처럼 아무런 소리를 내지 않을수도있다. 그리고 이러한 동작은 여러 서브클래스에 의해서 반복적으로 나타날 가능성이 매우 높다.

바뀌는 부분은 캡슐화를 해라인데 울다와 난다를 캡슐화를 하여 재사용성을 높일 수 있다.  
이러한 과정을 보면서 들었던 하나의 의문점은 그렇다면 `보여지는것` 메소드는 왜 캡슐화 하여 분리되는 대상이 되지 못할까? 였다.

좀더 자세히 확인해보면 보여지는것은 생성되는 서브클래스마다 모두 달라진다 즉 중복이 없다고 할 수 있다. 이러한 메소드는 재사용성이 없기때문에 캡슐화하는것보다는 개별 서브클래스에서 정의해 주는것이 맞다고 보여진다.

### 중복되는 메소드 재사용위한 캡슐화 하기

위 예제에서 캡슐화 하여 분리 할 수 있는 메소드는 울다 와 날다 이다.

```js
class 날다 {
  난다() {
    console.log('난다')
  }
  못난다() {
    console.log('못난다')
  }
}

class 울다 {
  꽥꽥() {
    console.log('꽥꽥')
  }
  삑삑() {
    console.log('삑삑')
  }
  무음() {
    return
  }
}
```

울다와 날다를 별도의 클래스로 분리하고 다양한 경우를 메소드로 작성한다.

```js
class 오리 {
  constructor() {
    this.날다 = null
    this.울다 = null
  }

  보여지는것() {
    console.log('오리')
  }

  수영() {
    console.log('수영')
  }

  set 날다입력(fn) {
    this.날다 = fn
  }
  set 울다입력(fn) {
    this.울다 = fn
  }
}
```

수퍼 클래스 에서는 캡슐화 하여 분리한 메소드를 주입받을 코드를 작성한다.

```js
const 청동 = new 청동오리()
const 고무 = new 고무오리()
const fly = new 날다()
const quact = new 울다()

청동.날다입력 = fly.난다
청동.날다() // 난다
고무.날다() // 고무.날다 is not a function
```

캡슐화하여 생성한 클래스에서 원하는 행동패턴을 주입해주면된다.  
다른 행동을 추가하고 싶다면 행동 클래스를 생성하고 수퍼클래스에 set 으로 작성만 해주면 어떤 하위클래스에도 해당 메소드를 필요한 곳에만 붙여서 사용할 수 있다.  
필요하지 않은 서브클래스엔 별도의 오버라이딩도 필요없다.

별도로 작성된 날다 와 울다는 오리클래스뿐만 아니라 어떤 클래스에도 유연하게 적용가능하다. 꽥꽥 소리가 나는 자동차 경적을 만들수도 있고, 날아다니는 자동차를 만들수도 있다.
